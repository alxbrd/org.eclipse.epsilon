pre {
	var EmfTool := new Native('org.eclipse.epsilon.emc.emf.tools.EmfTool');
}

context Object {	
	constraint IdentifiersMustBeUnique {
		guard: self.identifier.isDefined()
		check: self.identifier.isUniqueIdentifier()
		message: 'Duplicate identifier: ' + self.identifier
	}
}

context ClassObject {
	constraint ClassifierMustExist {
		guard: hasSpecificMetamodel()
		check: Metamodel!EClassifier.allInstances().select(c|c.name = self.type).size() = 1
		message: 'Unrecognised classifier: ' + self.type
	}
	
	constraint ClassifierMustBeClass {
		guard: self.satisfies('ClassifierMustExist')
		check: self.toClass().isDefined()
		message: 'Cannot instantiate the enumeration or data type: ' + self.type
	}
	
	constraint ClassMustNotBeAbstract {
		guard: self.satisfies('ClassifierMustBeClass')
		check: not self.toClass().isAbstract()
		message: 'Cannot instantiate the abstract class: ' + self.type
	}
	
	constraint ClassMustSpecifyRequiredFeatures {
		guard: self.satisfies('ClassMustNotBeAbstract')
		check: self.getAllFeaturesThatRequireAValueButDontHaveOne().isEmpty() 
		message: self.identifier + ' must specify a value for the following features: ' + self.getAllFeaturesThatRequireAValueButDontHaveOne().collect(f|f.name).toString()
	}
}

context Slot {
	constraint FeatureMustExist {
		guard: hasSpecificMetamodel() and self.owner.isTypeOf(ClassObject) and self.owner.toClass().isDefined() and self.feature.isDefined() 
		check: self.owner.toClass().eAllStructuralFeatures.select(c|c.name = self.feature).size() = 1
		message: 'Unrecognised feature: ' + self.feature
	}
}

context StringSlot {
	constraint FeatureMustAcceptStrings {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().eType.instanceTypeName = 'java.lang.String'
		message: 'Expected ' + self.toStructuralFeature().eType.name + ' for: ' + self.feature
	}
	
	constraint SingleValuedFeatureCannotTakeMultipleValues {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().isMany() or self.values.size = 1
		message: 'Multiple values not permitted for: ' + self.feature
	}
}

context IntegerSlot {
	constraint FeatureMustAcceptIntegers {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().eType.instanceTypeName = 'java.lang.Integer' or self.toStructuralFeature().eType.instanceTypeName = 'int'
		message: 'Expected ' + self.toStructuralFeature().eType.name + ' for: ' + self.feature
	}
	
	constraint SingleValuedFeatureCannotTakeMultipleValues {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().isMany() or self.values.size = 1
		message: 'Multiple values not permitted for: ' + self.feature
	}
}

context FloatSlot {
	constraint FeatureMustAcceptFloats {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().eType.instanceTypeName = 'java.lang.Float' or self.toStructuralFeature().eType.instanceTypeName = 'float'
		message: 'Expected ' + self.toStructuralFeature().eType.name + ' for: ' + self.feature
	}
	
	constraint SingleValuedFeatureCannotTakeMultipleValues {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().isMany() or self.values.size = 1
		message: 'Multiple values not permitted for: ' + self.feature
	}
}

context BooleanSlot {
	constraint FeatureMustAcceptBooleans {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().eType.instanceTypeName = 'java.lang.Boolean' or self.toStructuralFeature().eType.instanceTypeName = 'boolean'
		message: 'Expected ' + self.toStructuralFeature().eType.name + ' for: ' + self.feature
	}
	
	constraint SingleValuedFeatureCannotTakeMultipleValues {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().isMany() or self.values.size = 1
		message: 'Multiple values not permitted for: ' + self.feature
	}
}

context EnumSlot {
	constraint FeatureMustAcceptEnums {
		guard: self.satisfies('FeatureMustExist')
		check: self.toStructuralFeature().eType.isKindOf(Metamodel!EEnum)
		message: 'Expected ' + self.toStructuralFeature().eType.name + ' for: ' + self.feature
	}
}

context ReferenceSlot {
	constraint ReferencedIdentifiersMustExist {
		check: self.identifiers.forAll(i|i.isRecognisedIdentifier())
		message: self.identifiers.selectOne(i|not i.isRecognisedIdentifier()).getMessage()
				 
	}

	constraint SingleValuedFeatureCannotTakeMultipleValues {
		guard: self.satisfies('FeatureMustExist') and self.satisfies('ReferencedIdentifiersMustExist')
		check: self.toStructuralFeature().isMany() or self.identifiers.size = 1
		message: 'Multiple values not permitted for: ' + self.feature
	}

	constraint ReferencedIdentifiersMustBeOfRightType {
		guard: self.satisfies('FeatureMustExist') and self.satisfies('ReferencedIdentifiersMustExist') and self.satisfies('SingleValuedFeatureCannotTakeMultipleValues')
		check: self.identifiers.forAll(i|self.toStructuralFeature().eType.compatibleWith(i.toClass()))
		message: 'Expected ' + self.toStructuralFeature().eType.name + ' for: ' + self.feature
	}
}

operation hasSpecificMetamodel() : Boolean {
	return Spec.allInstances().at(0).nsUris.notEmpty();
}

operation String isUniqueIdentifier() : Boolean {
	return ClassObject.allInstances().select(c|c.identifier = self).size() = 1;
}

operation String isRecognisedIdentifier() : Boolean {
	if ('#'.isSubstringOf(self)) {		
		return self.canLocateExternalModel() and self.canLocateExternalModelElement();

	} else {
		return self.isUniqueIdentifier();
	}
}

operation String getMessage() : String {
	if ('#'.isSubstringOf(self)) {
		if (not self.canLocateExternalModel()) {
			return 'Model not found: ' + self.split('#').first();
		}
		
		return 'Model element not found: ' + self.split('#').last();
	
	} else {
		return 'Unrecognised identifier: ' + self;
	}
}

operation String canLocateExternalModel() : Boolean {
	return EmfTool.resourceExists(self.split('#').first());
}

operation String canLocateExternalModelElement() : Boolean {
	return EmfTool.modelElementExists(self);
}

operation Slot toStructuralFeature() : Metamodel!EStructuralFeature {
	var classifier : Metamodel!EClassifier := Metamodel!EClassifier.allInstances().select(c|c.name = self.owner.type).at(0);
	return Metamodel!EStructuralFeature.allInstances().select(c|c.name = self.feature and classifier.eAllStructuralFeatures.includes(c)).at(0);
}

operation String toClass() : Metamodel!EClassifier {
	if ('#'.isSubstringOf(self)) {
		-- External object reference, locate in external model

		var object := EmfTool.getEObject(self);
		
		if (object.isDefined()) {
			return object.eClass();
		}
	
	} else {
		-- Internal object reference, located in current model

		var object := ClassObject.allInstances().selectOne(c|c.identifier = self);
	
		if (object.isDefined()) {
			return object.toClass();
		}
	}
}

operation ClassObject toClass() : Metamodel!EClassifier {
	return Metamodel!EClass.allInstances().selectOne(c|c.name = self.type);
} 

operation Metamodel!EClassifier compatibleWith(classifier : Metamodel!EClassifier) : Boolean {
	if (classifier.isUndefined()) { return false; }
	
	
	return (self.getName() = classifier.getName() and 
	        self.getEPackage().getNsUri() = classifier.getEPackage().getNsUri()
	       ) or 
	       self.isSuperTypeOf(classifier);
}

operation Metamodel!EClass getAllFeaturesThatRequireAValue() : Sequence(EStructuralFeature) {
	return self.eAllStructuralFeatures.select(f|f.lowerBound = 1);
}

operation ClassObject getAllFeaturesThatRequireAValueButDontHaveOne() : Sequence(EStructuralFeature) {
    return self.toClass().getAllFeaturesThatRequireAValue().reject(f|self.slots.exists(s|s.feature = f.name));
}

operation Sequence toString() : String {
	var result : String := '';

	for (element in self) {
		result := result + element.toString();
		if (hasMore) { result := result + ', '; }
	}
	
	return result;
}