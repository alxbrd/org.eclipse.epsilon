\section{Task-Specific Languages}
\label{sec:TaskSpecificLanguages}

Having discussed EOL in detail, in the following chapters, the following task-specific languages built atop EOL are presented:

\begin{itemize}
	\item Epsilon Validation Language (EVL)
	\item Epsilon Transformation Language (ETL)
	\item Epsilon Generation Language (EGL)
	\item Epsilon Wizard Language (EWL)
	\item Epsilon Comparison Language (ECL)
	\item Epsilon Merging Language (EML)
\end{itemize}

For each language, the abstract and concrete syntax are presented. To enhance readability, the concrete syntax of each language is presented in an abstract, pseudo-grammar form. Also provided is an informal but detailed discussion, accompanied by concise examples for each feature of interest, of its execution semantics and the runtime structures that are essential to implement those semantics.

Descriptions of the abstract and concrete syntaxes of the task-specific languages are particularly brief since they inherit most of their syntax and features from EOL. As discussed earlier, this contributes to establishing a platform of uniform languages where each provides a number of unique task-specific constructs but does not otherwise deviate from each other.

To reduce unnecessary repetition, the following sections do not repeat all the features inherited from EOL. However, the reader should bear in mind that by being supersets of EOL, all task-specific languages can exploit the features it provides. For example, by reusing EOL's user-input facilities (discussed in \ref{sec:Design.EOL.UserInput}), it is feasible to specify interactive model to model transformations in ETL. As well, \emph{Native} types can be used to access or update information stored in an external system/tool (e.g. in a database or a remote server) during model validation with EVL or model comparison with ECL.

Following the presentation, in Chapters \ref{sec:EVL} -- \ref{sec:EML}, of the task-specific languages implemented in Epsilon, Chapter \ref{sec:Design.ImplementingANewLanguage} provides a brief overview of the process needed to construct a new language that addresses a task that is not supported by one of the existing languages.

\input{EVL}

\input{ETL}

\input{EWL}

\input{EGL}

\input{ECL}

\input{EML}

\input{Flock}

\input{NewLanguage}